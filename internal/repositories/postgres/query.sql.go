// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: query.sql

package postgres

import (
	"context"
	"database/sql"
)

const createFile = `-- name: CreateFile :exec
INSERT INTO files(user_tg_id, tg_id, url)
VALUES ($1, $2, $3)
`

type CreateFileParams struct {
	UserTgID sql.NullInt64
	TgID     sql.NullString
	Url      sql.NullString
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) error {
	_, err := q.db.Exec(ctx, createFile, arg.UserTgID, arg.TgID, arg.Url)
	return err
}

const createMessage = `-- name: CreateMessage :exec
INSERT INTO messages(user_tg_id, text)
VALUES ($1, $2)
`

type CreateMessageParams struct {
	UserTgID sql.NullInt64
	Text     sql.NullString
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) error {
	_, err := q.db.Exec(ctx, createMessage, arg.UserTgID, arg.Text)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users(tg_id, chat_id, role, first_name, last_name, user_name)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateUserParams struct {
	TgID      sql.NullInt64
	ChatID    sql.NullInt64
	Role      string
	FirstName sql.NullString
	LastName  sql.NullString
	UserName  sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.TgID,
		arg.ChatID,
		arg.Role,
		arg.FirstName,
		arg.LastName,
		arg.UserName,
	)
	return err
}

const readUser = `-- name: ReadUser :one
SELECT id, tg_id, chat_id, role, first_name, last_name, user_name FROM users
WHERE tg_id=$1
`

func (q *Queries) ReadUser(ctx context.Context, tgID sql.NullInt64) (User, error) {
	row := q.db.QueryRow(ctx, readUser, tgID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TgID,
		&i.ChatID,
		&i.Role,
		&i.FirstName,
		&i.LastName,
		&i.UserName,
	)
	return i, err
}

const readUsers = `-- name: ReadUsers :many
SELECT id, tg_id, chat_id, role, first_name, last_name, user_name FROM users
WHERE tg_id NOTNULL
`

func (q *Queries) ReadUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, readUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TgID,
			&i.ChatID,
			&i.Role,
			&i.FirstName,
			&i.LastName,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE users SET role=$1
where tg_id=$2
`

type UpdateUserRoleParams struct {
	Role string
	TgID sql.NullInt64
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.Role, arg.TgID)
	return err
}
